Data Spec Repository
========================

## Overview

This is a tool for making data according to specifications. The goal is to separate the structure of the data from the
values that populate it. We do this by defining two core concepts the Data Spec and the Field Spec. A Data Spec is used
to define all of the fields that should be generated for a record. The Data Spec does not care about the structure that the
data will populate. A single Data Spec could be used to generate JSON, XML, or a csv file. Each field in the Data Spec has its own
Field Spec that defines how the values for it should be created. There are a variety of core field types that are used to generate
the data for each field.  Where the built-in types are not sufficient, there is an easy way to create custom types and handlers for
them. The tool supports templating using the [Jinja2](https://pypi.org/project/Jinja2/) templating engine format.

## Build

To build a command line version of the tool:

```shell script
pyinstaller cli.py --name dataspec --onefile
```

The executable will be located in `dist/dataspec`

## Examples
See [examples](docs/EXAMPLES.md) to dive into detailed examples and practical use cases.

## Core Concepts
### Data Spec

A Data Spec is a Dictionary where the keys are the names of the fields to generate and each value is a [Field Spec](docs/FIELDSPECS.md)
that describes how the values for that field are to be generated. There is one reserved key in the root of the Data Spec: refs.
The refs is a special section of the Data Spec where Field Specs are defined but not tied to any specific field.  These
refs can then be used or referenced by other Specs. An example would be a combine Spec which points to two references that
should be joined. Below is an example Data Spec for creating email addresses.

```json
{
  "email": {
    "type": "combine",
    "refs": ["HANDLE", "DOMAINS"],
    "config": { "join_with": "@"}
  },
  "refs": { 
    "HANDLE": {
      "type": "combine",
      "refs": ["ANIMALS", "ACTIONS"],
      "config": { "join_with": "_"}
    },
    "ANIMALS": {
      "type": "values",
      "data": ["zebra", "hedgehog", "llama", "flamingo"]
    },
    "ACTIONS?sample=true": {
      "type": "values",
      "data": ["fling", "jump", "launch", "dispatch"]
    },
    "DOMAINS": {
      "type": "values",
      "data": {"gmail.com":  0.6, "yahoo.com": 0.3, "hotmail.com": 0.1}
    } 
  }
}
```

This Data Spec uses two Combine Specs to build up the pieces for the email address.  The first Combine Spec lives in the
Refs section. This one creates the user name or handle by combining the values generated by the ANIMALS Ref with the ACTIONS one.
The email field then combines the HANDLE Ref with the DOMAINS one.

Running dataspec from the command line against this spec:

```shell script
dist/dataspec -s ~/example.json -i 12
zebra_jump@gmail.com
hedgehog_launch@yahoo.com
llama_launch@yahoo.com
flamingo_launch@gmail.com
zebra_jump@hotmail.com
hedgehog_jump@hotmail.com
llama_dispatch@gmail.com
flamingo_fling@yahoo.com
zebra_fling@yahoo.com
hedgehog_launch@gmail.com
llama_jump@gmail.com
flamingo_jump@gmail.com
```

### Field Specs
See [field specs](docs/FIELDSPECS.md) for details.

### Templating
To populate a template file with the generated values for each iteration, pass the -t /path/to/template arg to the dataspec
command.  We use the [Jinja2](https://pypi.org/project/Jinja2/) templating engine under the hood.  The basic format is to put
the field names in {{ field name }} notation wherever they should be substituted.  For example the following is a template
for bulk indexing data into Elasticsearch.

```json
{ "index" : { "_index" : "test", "_id" : "{{ id }}" } }
{ "doc" : {"name" : "{{ name }}", "age": "{{ age }}", "gender": "{{ gender }}" } }
```

We could then create a spec to populate the id, name, age, and gender fields. Such as:
```json
{
  "id": {"type": "range", "data": [1, 10]},
  "gender": { "M":  0.48, "F":  0.52 },
  "name": [ "bob", "rob", "bobby", "bobo", "robert", "roberto", "bobby joe", "roby", "robi", "steve"],
  "age": { "type": "range", "data": [22,44,2] }
}
```

When we run the tool we get the data populated for the template:
```shell script
dist/dataspec -s ~/scratch/es-spec.json -t ~/scratch/template.json -i 10
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "doc" : {"name" : "bob", "age": "22", "gender": "F" } }
{ "index" : { "_index" : "test", "_id" : "2" } }
{ "doc" : {"name" : "rob", "age": "24", "gender": "F" } }
{ "index" : { "_index" : "test", "_id" : "3" } }
{ "doc" : {"name" : "bobby", "age": "26", "gender": "F" } }
{ "index" : { "_index" : "test", "_id" : "4" } }
...
```

### Custom Code Loading
There are a lot of types of data that are not generated with this tool. Instead of adding them all, there is a mechanism
to bring your own data suppliers. We make use of the handy [catalogue](https://pypi.org/project/catalogue/) library to
allow auto discovery of custom functions using decorators.  Use the @dataspec.registry.types('\<type key\>') to register a
function that will create a Value Supplier for the supplied Field Spec. Below is an example of a custom class which reverses the output
of another supplier. Types that are amazing and useful should be nominated for core inclusion. Please put up a PR if you
create or use one that solves many of your data generation issues.

```python
import dataspec

class ReverseStringSupplier:
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def next(self, iteration):
        # value from the wrapped supplier
        value = str(self.wrapped.next(iteration))
        # python way to reverse a string, hehe
        return value[::-1]


@dataspec.registry.types('reverse_string')
def configure_supplier(field_spec, loader):
    # load the supplier for the given ref
    key = field_spec.get('ref')
    spec = loader.refs.get(key)
    wrapped = loader.get_from_spec(spec)
    # wrap this with our custom reverse string supplier
    return ReverseStringSupplier(wrapped)
```

Now when we see a type of "reverse_string" like in the example below, we will use the given function to configure the
supplier for it. The function name for the decorated function is arbitrary, but the signature must match. The signature
for the Value Supplier is required to match the interface and have a single `next(iteration)` method that returns the
next value for the given iteration.
```
{
  "backwards": {
    "type": "reverse_string",
    "ref": "ANIMALS"
  },
  "refs": { 
    "ANIMALS": {
      "type": "values",
      "data": ["zebra", "hedgehog", "llama", "flamingo"]
    }
  }
}
```

To supply custom code to the tool use the -c or --code arguments. One or more module files can be imported.
```shell script
.dist/dataspec -s reverse-spec.json -i 4 -c custom.py another.py
arbez
gohegdeh
amall
ognimalf
```
